\documentclass[answers,12pt,addpoints]{exam}
\usepackage{import}

\import{C:/Users/prana/OneDrive/Desktop/MathNotes}{style.tex}

\usepackage[margin=.25in, includehead, includefoot, headheight=0pt]{geometry}
\usepackage{setspace}
\setstretch{0}

% Header
\newcommand{\name}{Pranav Tikkawar}
\newcommand{\course}{01:198:211}
\newcommand{\assignment}{Exam 1 Cheat Sheet}
\author{\name}




\begin{document}
\begin{center}
    Trends in Computer Architecture
\end{center}
Observed that the number of transistors on a chip double every 18 months. \\
Memory capacity doubles every 2 years. \\
Disk capacity doubles every year. \\
\textbf{Components:} CPu, Memory, System Bus, IO bus, storage, peripherals. \\
\textbf{Moore's law}: number of transistors on a chip double every 18 months. \\
\textbf{Von Neumann Model}: single memory space store both instructions and data. \\
\textbf{Multicore crisis}: diminishing returns for multiple core clock speed.\\
\textbf{Power Wall:} Power consumption increases with clock speed. it levels out because cooling and heat become an issue
\textbf{Memory Wall:} Memory access time is slower than CPU speed. 
\begin{center}
    C info
\end{center}
\textbf{Pointer:}  int *p; (declare pointer which points to an int), p = \&x; (point to x), *p = 5; (set x to 5). \&x is the address of x. \\
\textbf{Array:} int a[20]; (declare array of size 20), int *ptr = a; (pointer to array) acts as a[0]. \\
\textbf{Multi Dimensional Array:} int a[2][3]; (2D array), int *ptr = a; (pointer to 2D array) acts as a[0]. a[0] $\sim$ first row, a[0][0] $\sim$ first element of first row. *(m+2)+1 = \&m[2][1]\\
\textbf{Memory:} Malloc: create objects on the heap: int *numbers = (int *)malloc(sizeof(int) * n); free to deallocate. free(numbers) \\
\textbf{Struct:} struct point \{ int x; int y; \}; struct point p; p.x = 5; p.y = 10; if we pass a pointer of a struct we do struct point *p; p = (struct point *)malloc(sizeof(struct point)); p$\to$x = 5; p$\to$y = 10; \\
\textbf{Strings:} Treat as array of chars followed by null. "\textbackslash 0". \texttt{strcpy}(s, "bar") to copy value but not same object. \texttt{strlen}(s) to get length. \texttt{strcmp}(s, t) to compare. \texttt{strcat}(s, t) to concatenate.\\
\textbf{Input/Output:} \texttt{scanf} and \texttt{printf} for input and output. \%d for int, \%f for float, \%s for string. add f to the front of most operation to put them to a file. 
\begin{center}
    Assembly
\end{center}
\textbf{Cycle}: Fetch, Decode, Execute. CISC $\sim$ complex, RISC $\sim$ simple. \texttt{opcode src dest} where opcode is the operation, src is the source, dest is the destination. \\
\textbf{Registers:} EAX, EBX, 32 bit, AX, BX, 16 bit, AH, AL, 8 bit. end x is like variable, end p/i is pointer/index. \\
\textbf{Type of operands} \texttt{movl \$eax, \%ebx}  copy contnet of \%eax to \%ebx; \texttt{movl \$0x1, \%eax} copy 0x1 to \%eax; \texttt{movl \%eax, 0x1} copy \%eax to memory location 0x1; \texttt{movl (\%ebp, \%esi), \%eax} copy value at address = ebp + esi to \%eax; \texttt{movl 8(\%ebp, \%esi), \%eax} copy value at address = ebp + esi + 8 to \%eax; \texttt{movl 0x80 (\%ebx, \%esi, 4), \%eax} copy value at address = ebx + esi*4 + 0x80 to \%eax \\
\textbf{Operations:} \texttt{movl, src, dest} dest = src.  \texttt{pushl src} esp = esp-4 then move M[esp] = src  \texttt{popl src} src = M[esp] then esp = esp+4. \texttt{leal} compute address using addressing mode without accessing memory
\textbf{Flags} \texttt{ZF} zero flag it is zero, \texttt{SF} sign flag if it is negative, \texttt{OF} overflow flag if it is too big in 2s complement, \texttt{CF} carry flag if it is too big in unsigned. 
\begin{center}
    Number theory
\end{center}
\textbf{Hexadecimal:} $A_{16} = 10_{10}$, $F_{16} = 15_{10}$, $10_{16} = 16_{10}$, Uses 16 bits so 2 bytes. (think float = 32 bit, 4 bytes, 4 digits) \\
\textbf{Binary:} $1010_2 = 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 10_{10}$ \\
\textbf{Sign-Magnitutde}: First bit is sign, rest is magnitude. $-5_{10} = 1001_2$ Arithmatic is odd, distinct $\pm0$ \\
\textbf{1's Complement}: Negate by flipping bits. $-5_{10} = 1110_2$ Arithmatic is mostly normal, distinct $\pm0$ \\
\textbf{2's Complement}: Negate by flipping bits and adding 1. $-5_{10} = 1011_2$ Arithmatic is normal, distinct $0$ \\
\textbf{IEEE}: sign, exp, mantissa. $\to$ sign $\cdot$ $2^{e-b}$ $\cdot$ mantissa Bias: e = num exp bits, b = $2^{e-1}-1$. subnormal, with all 0 exp leads to 0 as first digit \\
\textbf{Special values:} 0 = all zeros, $\pm \infty$ = all ones in exp, 0 in mantissa, change sign. NaN = all ones in exp, non-zero mantissa. \\




\end{document}